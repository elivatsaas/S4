Single Responsibility Principle:

The EmployeeType class is only there to store all of the employees, and is only changed when an employee is added or removed (class below):

class EmployeeType
    {
    private:
        int arrSize;

    public:
        Employee *empArr;
        int employeeCount;
        int totalRequested;

        EmployeeType()
        {
            employeeCount = 0;
            empArr = new Employee[0];
            arrSize = 0;
        }
        EmployeeType(int empCount)
        {
            employeeCount = empCount;
            empArr = new Employee[empCount];
            arrSize = 0;
        }
        void setArrSize(int newSize)
        {
            arrSize = newSize;
        }
        void incrementArrSize()
        {
            setArrSize(arrSize + 1);
        }
        void decrementArrSize()
        {
            setArrSize(arrSize - 1);
        }
        int getArrSize()
        {
            return arrSize;
        }
    };


Open/Closed Principle:

Within that same EmployeeType class the class is open to use the employee struct however the EmployeeType does not use any of the employee struct itself.


Liskov Substitution Principle:

In main we could replace employees.empArr with a new pointer array of employees built within main and the code would function the same. Here is an example of one line that could change:

employees.empArr[loopIndex].shiftList = new Shift[shiftCount]; 
to
Employee *empArr[employeeCount[
empArr[loopIndex].shiftList = new Shift[shiftCount];


Interface Segregation Principle:

At the time of this deliverable this is not yet implemented, however we plan to add the ability to input for seperate stores. However in the case of only 1 store existing we will forgo that option and it wont be necessary to use.


Dependency Inversion Principle:

Within the algorithm that assigns an employee to all the shifts, we must make sure that the employee we are trying to assign do not already have overlapping shifts. The line of code that does this is as follows: 

if(!checkForOverlap(employees->empArr[empExists], shifts->sftArr[shiftIndex]))

This line does not care how the checkForOverlap function works, and there are many different ways to implement this function, it just needs to know if this employee has an overlap with this shift. 
